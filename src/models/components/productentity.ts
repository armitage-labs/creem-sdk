/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  EnvironmentMode,
  EnvironmentMode$inboundSchema,
  EnvironmentMode$outboundSchema,
} from "./environmentmode.js";
import {
  FeatureEntity,
  FeatureEntity$inboundSchema,
  FeatureEntity$Outbound,
  FeatureEntity$outboundSchema,
} from "./featureentity.js";
import {
  ProductBillingPeriod,
  ProductBillingPeriod$inboundSchema,
  ProductBillingPeriod$outboundSchema,
} from "./productbillingperiod.js";
import {
  ProductBillingType,
  ProductBillingType$inboundSchema,
  ProductBillingType$outboundSchema,
} from "./productbillingtype.js";
import {
  ProductStatus,
  ProductStatus$inboundSchema,
  ProductStatus$outboundSchema,
} from "./productstatus.js";
import {
  TaxCategory,
  TaxCategory$inboundSchema,
  TaxCategory$outboundSchema,
} from "./taxcategory.js";
import {
  TaxMode,
  TaxMode$inboundSchema,
  TaxMode$outboundSchema,
} from "./taxmode.js";

export type ProductEntity = {
  /**
   * Unique identifier for the object.
   */
  id: string;
  /**
   * String representing the environment.
   */
  mode: EnvironmentMode;
  /**
   * String representing the object's type. Objects of the same type share the same value.
   */
  object: string;
  /**
   * The name of the product
   */
  name: string;
  /**
   * A brief description of the product
   */
  description: string;
  /**
   * URL of the product image. Only png as jpg are supported
   */
  imageUrl?: string | undefined;
  /**
   * Features of the product.
   */
  features?: Array<FeatureEntity> | undefined;
  /**
   * The price of the product in cents. 1000 = $10.00
   */
  price: number;
  /**
   * Three-letter ISO currency code, in uppercase. Must be a supported currency.
   */
  currency: string;
  /**
   * Indicates the billing method for the customer. It can either be a `recurring` billing cycle or a `onetime` payment.
   */
  billingType: ProductBillingType;
  /**
   * Billing period
   */
  billingPeriod: ProductBillingPeriod;
  /**
   * Status of the product
   */
  status: ProductStatus;
  /**
   * Specifies the tax calculation mode for the transaction. If set to "inclusive," the tax is included in the price. If set to "exclusive," the tax is added on top of the price.
   */
  taxMode: TaxMode;
  /**
   * Categorizes the type of product or service for tax purposes. This helps determine the applicable tax rules based on the nature of the item or service.
   */
  taxCategory: TaxCategory;
  /**
   * The product page you can redirect your customers to for express checkout.
   */
  productUrl?: string | undefined;
  /**
   * The URL to which the user will be redirected after successfull payment.
   */
  defaultSuccessUrl?: string | null | undefined;
  /**
   * Creation date of the product
   */
  createdAt: Date;
  /**
   * Last updated date of the product
   */
  updatedAt: Date;
};

/** @internal */
export const ProductEntity$inboundSchema: z.ZodType<
  ProductEntity,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  mode: EnvironmentMode$inboundSchema,
  object: z.string(),
  name: z.string(),
  description: z.string(),
  image_url: z.string().optional(),
  features: z.array(FeatureEntity$inboundSchema).optional(),
  price: z.number(),
  currency: z.string(),
  billing_type: ProductBillingType$inboundSchema,
  billing_period: ProductBillingPeriod$inboundSchema,
  status: ProductStatus$inboundSchema,
  tax_mode: TaxMode$inboundSchema,
  tax_category: TaxCategory$inboundSchema,
  product_url: z.string().optional(),
  default_success_url: z.nullable(z.string()).optional(),
  created_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  updated_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
}).transform((v) => {
  return remap$(v, {
    "image_url": "imageUrl",
    "billing_type": "billingType",
    "billing_period": "billingPeriod",
    "tax_mode": "taxMode",
    "tax_category": "taxCategory",
    "product_url": "productUrl",
    "default_success_url": "defaultSuccessUrl",
    "created_at": "createdAt",
    "updated_at": "updatedAt",
  });
});
/** @internal */
export type ProductEntity$Outbound = {
  id: string;
  mode: string;
  object: string;
  name: string;
  description: string;
  image_url?: string | undefined;
  features?: Array<FeatureEntity$Outbound> | undefined;
  price: number;
  currency: string;
  billing_type: string;
  billing_period: string;
  status: string;
  tax_mode: string;
  tax_category: string;
  product_url?: string | undefined;
  default_success_url?: string | null | undefined;
  created_at: string;
  updated_at: string;
};

/** @internal */
export const ProductEntity$outboundSchema: z.ZodType<
  ProductEntity$Outbound,
  z.ZodTypeDef,
  ProductEntity
> = z.object({
  id: z.string(),
  mode: EnvironmentMode$outboundSchema,
  object: z.string(),
  name: z.string(),
  description: z.string(),
  imageUrl: z.string().optional(),
  features: z.array(FeatureEntity$outboundSchema).optional(),
  price: z.number(),
  currency: z.string(),
  billingType: ProductBillingType$outboundSchema,
  billingPeriod: ProductBillingPeriod$outboundSchema,
  status: ProductStatus$outboundSchema,
  taxMode: TaxMode$outboundSchema,
  taxCategory: TaxCategory$outboundSchema,
  productUrl: z.string().optional(),
  defaultSuccessUrl: z.nullable(z.string()).optional(),
  createdAt: z.date().transform(v => v.toISOString()),
  updatedAt: z.date().transform(v => v.toISOString()),
}).transform((v) => {
  return remap$(v, {
    imageUrl: "image_url",
    billingType: "billing_type",
    billingPeriod: "billing_period",
    taxMode: "tax_mode",
    taxCategory: "tax_category",
    productUrl: "product_url",
    defaultSuccessUrl: "default_success_url",
    createdAt: "created_at",
    updatedAt: "updated_at",
  });
});

export function productEntityToJSON(productEntity: ProductEntity): string {
  return JSON.stringify(ProductEntity$outboundSchema.parse(productEntity));
}
export function productEntityFromJSON(
  jsonString: string,
): SafeParseResult<ProductEntity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ProductEntity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ProductEntity' from JSON`,
  );
}
