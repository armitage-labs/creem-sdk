/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  FeatureEntity,
  FeatureEntity$inboundSchema,
  FeatureEntity$Outbound,
  FeatureEntity$outboundSchema,
} from "./featureentity.js";

/**
 * String representing the environment.
 */
export const Mode = {
  Test: "test",
  Live: "live",
  Sandbox: "sandbox",
} as const;
/**
 * String representing the environment.
 */
export type Mode = ClosedEnum<typeof Mode>;

/**
 * String representing the object’s type. Objects of the same type share the same value.
 */
export type ObjectT = {};

/**
 * URL of the product image. Only png as jpg are supported
 */
export type ImageUrl = {};

export type ProductEntity = {
  /**
   * Unique identifier for the object.
   */
  id: string;
  /**
   * String representing the environment.
   */
  mode: Mode;
  /**
   * String representing the object’s type. Objects of the same type share the same value.
   */
  object?: ObjectT | undefined;
  /**
   * The name of the product
   */
  name: string;
  /**
   * A brief description of the product
   */
  description: string;
  /**
   * URL of the product image. Only png as jpg are supported
   */
  imageUrl?: ImageUrl | undefined;
  /**
   * Features of the product.
   */
  features?: Array<FeatureEntity> | undefined;
  /**
   * The price of the product in cents. 1000 = $10.00
   */
  price: number;
  /**
   * Three-letter ISO currency code, in uppercase. Must be a supported currency.
   */
  currency: string;
  /**
   * Indicates the billing method for the customer. It can either be a `recurring` billing cycle or a `onetime` payment.
   */
  billingType: string;
  /**
   * Billing period
   */
  billingPeriod: string;
  /**
   * Status of the product
   */
  status: string;
  /**
   * Specifies the tax calculation mode for the transaction. If set to "inclusive," the tax is included in the price. If set to "exclusive," the tax is added on top of the price.
   */
  taxMode: string;
  /**
   * Categorizes the type of product or service for tax purposes. This helps determine the applicable tax rules based on the nature of the item or service.
   */
  taxCategory: string;
  /**
   * The product page you can redirect your customers to for express checkout.
   */
  productUrl: string;
  /**
   * The URL to which the user will be redirected after successfull payment.
   */
  defaultSuccessUrl?: string | undefined;
  /**
   * Creation date of the product
   */
  createdAt: Date;
  /**
   * Last updated date of the product
   */
  updatedAt: Date;
};

/** @internal */
export const Mode$inboundSchema: z.ZodNativeEnum<typeof Mode> = z.nativeEnum(
  Mode,
);

/** @internal */
export const Mode$outboundSchema: z.ZodNativeEnum<typeof Mode> =
  Mode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Mode$ {
  /** @deprecated use `Mode$inboundSchema` instead. */
  export const inboundSchema = Mode$inboundSchema;
  /** @deprecated use `Mode$outboundSchema` instead. */
  export const outboundSchema = Mode$outboundSchema;
}

/** @internal */
export const ObjectT$inboundSchema: z.ZodType<ObjectT, z.ZodTypeDef, unknown> =
  z.object({});

/** @internal */
export type ObjectT$Outbound = {};

/** @internal */
export const ObjectT$outboundSchema: z.ZodType<
  ObjectT$Outbound,
  z.ZodTypeDef,
  ObjectT
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ObjectT$ {
  /** @deprecated use `ObjectT$inboundSchema` instead. */
  export const inboundSchema = ObjectT$inboundSchema;
  /** @deprecated use `ObjectT$outboundSchema` instead. */
  export const outboundSchema = ObjectT$outboundSchema;
  /** @deprecated use `ObjectT$Outbound` instead. */
  export type Outbound = ObjectT$Outbound;
}

export function objectToJSON(objectT: ObjectT): string {
  return JSON.stringify(ObjectT$outboundSchema.parse(objectT));
}

export function objectFromJSON(
  jsonString: string,
): SafeParseResult<ObjectT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ObjectT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ObjectT' from JSON`,
  );
}

/** @internal */
export const ImageUrl$inboundSchema: z.ZodType<
  ImageUrl,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type ImageUrl$Outbound = {};

/** @internal */
export const ImageUrl$outboundSchema: z.ZodType<
  ImageUrl$Outbound,
  z.ZodTypeDef,
  ImageUrl
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ImageUrl$ {
  /** @deprecated use `ImageUrl$inboundSchema` instead. */
  export const inboundSchema = ImageUrl$inboundSchema;
  /** @deprecated use `ImageUrl$outboundSchema` instead. */
  export const outboundSchema = ImageUrl$outboundSchema;
  /** @deprecated use `ImageUrl$Outbound` instead. */
  export type Outbound = ImageUrl$Outbound;
}

export function imageUrlToJSON(imageUrl: ImageUrl): string {
  return JSON.stringify(ImageUrl$outboundSchema.parse(imageUrl));
}

export function imageUrlFromJSON(
  jsonString: string,
): SafeParseResult<ImageUrl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ImageUrl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ImageUrl' from JSON`,
  );
}

/** @internal */
export const ProductEntity$inboundSchema: z.ZodType<
  ProductEntity,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  mode: Mode$inboundSchema,
  object: z.lazy(() => ObjectT$inboundSchema).optional(),
  name: z.string(),
  description: z.string(),
  image_url: z.lazy(() => ImageUrl$inboundSchema).optional(),
  features: z.array(FeatureEntity$inboundSchema).optional(),
  price: z.number(),
  currency: z.string(),
  billing_type: z.string(),
  billing_period: z.string(),
  status: z.string(),
  tax_mode: z.string(),
  tax_category: z.string(),
  product_url: z.string(),
  default_success_url: z.string().optional(),
  created_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  updated_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
}).transform((v) => {
  return remap$(v, {
    "image_url": "imageUrl",
    "billing_type": "billingType",
    "billing_period": "billingPeriod",
    "tax_mode": "taxMode",
    "tax_category": "taxCategory",
    "product_url": "productUrl",
    "default_success_url": "defaultSuccessUrl",
    "created_at": "createdAt",
    "updated_at": "updatedAt",
  });
});

/** @internal */
export type ProductEntity$Outbound = {
  id: string;
  mode: string;
  object?: ObjectT$Outbound | undefined;
  name: string;
  description: string;
  image_url?: ImageUrl$Outbound | undefined;
  features?: Array<FeatureEntity$Outbound> | undefined;
  price: number;
  currency: string;
  billing_type: string;
  billing_period: string;
  status: string;
  tax_mode: string;
  tax_category: string;
  product_url: string;
  default_success_url?: string | undefined;
  created_at: string;
  updated_at: string;
};

/** @internal */
export const ProductEntity$outboundSchema: z.ZodType<
  ProductEntity$Outbound,
  z.ZodTypeDef,
  ProductEntity
> = z.object({
  id: z.string(),
  mode: Mode$outboundSchema,
  object: z.lazy(() => ObjectT$outboundSchema).optional(),
  name: z.string(),
  description: z.string(),
  imageUrl: z.lazy(() => ImageUrl$outboundSchema).optional(),
  features: z.array(FeatureEntity$outboundSchema).optional(),
  price: z.number(),
  currency: z.string(),
  billingType: z.string(),
  billingPeriod: z.string(),
  status: z.string(),
  taxMode: z.string(),
  taxCategory: z.string(),
  productUrl: z.string(),
  defaultSuccessUrl: z.string().optional(),
  createdAt: z.date().transform(v => v.toISOString()),
  updatedAt: z.date().transform(v => v.toISOString()),
}).transform((v) => {
  return remap$(v, {
    imageUrl: "image_url",
    billingType: "billing_type",
    billingPeriod: "billing_period",
    taxMode: "tax_mode",
    taxCategory: "tax_category",
    productUrl: "product_url",
    defaultSuccessUrl: "default_success_url",
    createdAt: "created_at",
    updatedAt: "updated_at",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ProductEntity$ {
  /** @deprecated use `ProductEntity$inboundSchema` instead. */
  export const inboundSchema = ProductEntity$inboundSchema;
  /** @deprecated use `ProductEntity$outboundSchema` instead. */
  export const outboundSchema = ProductEntity$outboundSchema;
  /** @deprecated use `ProductEntity$Outbound` instead. */
  export type Outbound = ProductEntity$Outbound;
}

export function productEntityToJSON(productEntity: ProductEntity): string {
  return JSON.stringify(ProductEntity$outboundSchema.parse(productEntity));
}

export function productEntityFromJSON(
  jsonString: string,
): SafeParseResult<ProductEntity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ProductEntity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ProductEntity' from JSON`,
  );
}
