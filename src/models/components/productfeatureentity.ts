/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  EnvironmentMode,
  EnvironmentMode$inboundSchema,
  EnvironmentMode$outboundSchema,
} from "./environmentmode.js";
import {
  FileFeatureEntity,
  FileFeatureEntity$inboundSchema,
  FileFeatureEntity$Outbound,
  FileFeatureEntity$outboundSchema,
} from "./filefeatureentity.js";
import {
  LicenseEntity,
  LicenseEntity$inboundSchema,
  LicenseEntity$Outbound,
  LicenseEntity$outboundSchema,
} from "./licenseentity.js";
import {
  ProductFeatureType,
  ProductFeatureType$inboundSchema,
  ProductFeatureType$outboundSchema,
} from "./productfeaturetype.js";

/**
 * The current status of the license key.
 */
export const ProductFeatureEntityStatus = {
  Inactive: "inactive",
  Active: "active",
  Expired: "expired",
  Disabled: "disabled",
} as const;
/**
 * The current status of the license key.
 */
export type ProductFeatureEntityStatus = ClosedEnum<
  typeof ProductFeatureEntityStatus
>;

/**
 * The activation limit. Null if activations are unlimited.
 */
export type ProductFeatureEntityActivationLimit = {};

/**
 * The date the license key expires. Null if it does not have an expiration date.
 */
export type ProductFeatureEntityExpiresAt = {};

/**
 * The status of the license instance.
 */
export const ProductFeatureEntityLicenseStatus = {
  Active: "active",
  Deactivated: "deactivated",
} as const;
/**
 * The status of the license instance.
 */
export type ProductFeatureEntityLicenseStatus = ClosedEnum<
  typeof ProductFeatureEntityLicenseStatus
>;

/**
 * Associated license instances.
 */
export type ProductFeatureEntityInstance = {
  /**
   * Unique identifier for the object.
   */
  id: string;
  /**
   * String representing the environment.
   */
  mode: EnvironmentMode;
  /**
   * A string representing the object’s type. Objects of the same type share the same value.
   */
  object: string;
  /**
   * The name of the license instance.
   */
  name: string;
  /**
   * The status of the license instance.
   */
  status: ProductFeatureEntityLicenseStatus;
  /**
   * The creation date of the license instance.
   */
  createdAt: Date;
};

/**
 * DEPRECATED: Use `license_key` instead. License key issued for the order.
 *
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type License = {
  /**
   * Unique identifier for the object.
   */
  id: string;
  /**
   * String representing the environment.
   */
  mode: EnvironmentMode;
  /**
   * A string representing the object’s type. Objects of the same type share the same value.
   */
  object: string;
  /**
   * The current status of the license key.
   */
  status: ProductFeatureEntityStatus;
  /**
   * The license key.
   */
  key: string;
  /**
   * The number of instances that this license key was activated.
   */
  activation: number;
  /**
   * The activation limit. Null if activations are unlimited.
   */
  activationLimit?: ProductFeatureEntityActivationLimit | null | undefined;
  /**
   * The date the license key expires. Null if it does not have an expiration date.
   */
  expiresAt?: ProductFeatureEntityExpiresAt | null | undefined;
  /**
   * The creation date of the license key.
   */
  createdAt: Date;
  /**
   * Associated license instances.
   */
  instance?: ProductFeatureEntityInstance | null | undefined;
};

export type ProductFeatureEntity = {
  /**
   * Unique identifier for the feature.
   */
  id?: string | undefined;
  /**
   * A brief description of the feature.
   */
  description?: string | undefined;
  /**
   * The type of the feature: privateNote (custom note), file (downloadable files), or licenseKey (license key).
   */
  type?: ProductFeatureType | undefined;
  /**
   * Private note from the seller. This is only visible to the customer after purchase.
   */
  privateNote?: string | undefined;
  /**
   * File feature data containing downloadable files.
   */
  file?: FileFeatureEntity | undefined;
  /**
   * License key issued for the order.
   */
  licenseKey?: LicenseEntity | undefined;
  /**
   * DEPRECATED: Use `license_key` instead. License key issued for the order.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  license?: License | undefined;
};

/** @internal */
export const ProductFeatureEntityStatus$inboundSchema: z.ZodNativeEnum<
  typeof ProductFeatureEntityStatus
> = z.nativeEnum(ProductFeatureEntityStatus);
/** @internal */
export const ProductFeatureEntityStatus$outboundSchema: z.ZodNativeEnum<
  typeof ProductFeatureEntityStatus
> = ProductFeatureEntityStatus$inboundSchema;

/** @internal */
export const ProductFeatureEntityActivationLimit$inboundSchema: z.ZodType<
  ProductFeatureEntityActivationLimit,
  z.ZodTypeDef,
  unknown
> = z.object({});
/** @internal */
export type ProductFeatureEntityActivationLimit$Outbound = {};

/** @internal */
export const ProductFeatureEntityActivationLimit$outboundSchema: z.ZodType<
  ProductFeatureEntityActivationLimit$Outbound,
  z.ZodTypeDef,
  ProductFeatureEntityActivationLimit
> = z.object({});

export function productFeatureEntityActivationLimitToJSON(
  productFeatureEntityActivationLimit: ProductFeatureEntityActivationLimit,
): string {
  return JSON.stringify(
    ProductFeatureEntityActivationLimit$outboundSchema.parse(
      productFeatureEntityActivationLimit,
    ),
  );
}
export function productFeatureEntityActivationLimitFromJSON(
  jsonString: string,
): SafeParseResult<ProductFeatureEntityActivationLimit, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ProductFeatureEntityActivationLimit$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ProductFeatureEntityActivationLimit' from JSON`,
  );
}

/** @internal */
export const ProductFeatureEntityExpiresAt$inboundSchema: z.ZodType<
  ProductFeatureEntityExpiresAt,
  z.ZodTypeDef,
  unknown
> = z.object({});
/** @internal */
export type ProductFeatureEntityExpiresAt$Outbound = {};

/** @internal */
export const ProductFeatureEntityExpiresAt$outboundSchema: z.ZodType<
  ProductFeatureEntityExpiresAt$Outbound,
  z.ZodTypeDef,
  ProductFeatureEntityExpiresAt
> = z.object({});

export function productFeatureEntityExpiresAtToJSON(
  productFeatureEntityExpiresAt: ProductFeatureEntityExpiresAt,
): string {
  return JSON.stringify(
    ProductFeatureEntityExpiresAt$outboundSchema.parse(
      productFeatureEntityExpiresAt,
    ),
  );
}
export function productFeatureEntityExpiresAtFromJSON(
  jsonString: string,
): SafeParseResult<ProductFeatureEntityExpiresAt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ProductFeatureEntityExpiresAt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ProductFeatureEntityExpiresAt' from JSON`,
  );
}

/** @internal */
export const ProductFeatureEntityLicenseStatus$inboundSchema: z.ZodNativeEnum<
  typeof ProductFeatureEntityLicenseStatus
> = z.nativeEnum(ProductFeatureEntityLicenseStatus);
/** @internal */
export const ProductFeatureEntityLicenseStatus$outboundSchema: z.ZodNativeEnum<
  typeof ProductFeatureEntityLicenseStatus
> = ProductFeatureEntityLicenseStatus$inboundSchema;

/** @internal */
export const ProductFeatureEntityInstance$inboundSchema: z.ZodType<
  ProductFeatureEntityInstance,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  mode: EnvironmentMode$inboundSchema,
  object: z.string(),
  name: z.string(),
  status: ProductFeatureEntityLicenseStatus$inboundSchema,
  created_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
}).transform((v) => {
  return remap$(v, {
    "created_at": "createdAt",
  });
});
/** @internal */
export type ProductFeatureEntityInstance$Outbound = {
  id: string;
  mode: string;
  object: string;
  name: string;
  status: string;
  created_at: string;
};

/** @internal */
export const ProductFeatureEntityInstance$outboundSchema: z.ZodType<
  ProductFeatureEntityInstance$Outbound,
  z.ZodTypeDef,
  ProductFeatureEntityInstance
> = z.object({
  id: z.string(),
  mode: EnvironmentMode$outboundSchema,
  object: z.string(),
  name: z.string(),
  status: ProductFeatureEntityLicenseStatus$outboundSchema,
  createdAt: z.date().transform(v => v.toISOString()),
}).transform((v) => {
  return remap$(v, {
    createdAt: "created_at",
  });
});

export function productFeatureEntityInstanceToJSON(
  productFeatureEntityInstance: ProductFeatureEntityInstance,
): string {
  return JSON.stringify(
    ProductFeatureEntityInstance$outboundSchema.parse(
      productFeatureEntityInstance,
    ),
  );
}
export function productFeatureEntityInstanceFromJSON(
  jsonString: string,
): SafeParseResult<ProductFeatureEntityInstance, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ProductFeatureEntityInstance$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ProductFeatureEntityInstance' from JSON`,
  );
}

/** @internal */
export const License$inboundSchema: z.ZodType<License, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string(),
    mode: EnvironmentMode$inboundSchema,
    object: z.string(),
    status: ProductFeatureEntityStatus$inboundSchema,
    key: z.string(),
    activation: z.number(),
    activation_limit: z.nullable(
      z.lazy(() => ProductFeatureEntityActivationLimit$inboundSchema),
    ).optional(),
    expires_at: z.nullable(
      z.lazy(() => ProductFeatureEntityExpiresAt$inboundSchema),
    ).optional(),
    created_at: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ),
    instance: z.nullable(
      z.lazy(() => ProductFeatureEntityInstance$inboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "activation_limit": "activationLimit",
      "expires_at": "expiresAt",
      "created_at": "createdAt",
    });
  });
/** @internal */
export type License$Outbound = {
  id: string;
  mode: string;
  object: string;
  status: string;
  key: string;
  activation: number;
  activation_limit?:
    | ProductFeatureEntityActivationLimit$Outbound
    | null
    | undefined;
  expires_at?: ProductFeatureEntityExpiresAt$Outbound | null | undefined;
  created_at: string;
  instance?: ProductFeatureEntityInstance$Outbound | null | undefined;
};

/** @internal */
export const License$outboundSchema: z.ZodType<
  License$Outbound,
  z.ZodTypeDef,
  License
> = z.object({
  id: z.string(),
  mode: EnvironmentMode$outboundSchema,
  object: z.string(),
  status: ProductFeatureEntityStatus$outboundSchema,
  key: z.string(),
  activation: z.number(),
  activationLimit: z.nullable(
    z.lazy(() => ProductFeatureEntityActivationLimit$outboundSchema),
  ).optional(),
  expiresAt: z.nullable(
    z.lazy(() => ProductFeatureEntityExpiresAt$outboundSchema),
  ).optional(),
  createdAt: z.date().transform(v => v.toISOString()),
  instance: z.nullable(
    z.lazy(() => ProductFeatureEntityInstance$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    activationLimit: "activation_limit",
    expiresAt: "expires_at",
    createdAt: "created_at",
  });
});

export function licenseToJSON(license: License): string {
  return JSON.stringify(License$outboundSchema.parse(license));
}
export function licenseFromJSON(
  jsonString: string,
): SafeParseResult<License, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => License$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'License' from JSON`,
  );
}

/** @internal */
export const ProductFeatureEntity$inboundSchema: z.ZodType<
  ProductFeatureEntity,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  description: z.string().optional(),
  type: ProductFeatureType$inboundSchema.optional(),
  private_note: z.string().optional(),
  file: FileFeatureEntity$inboundSchema.optional(),
  license_key: LicenseEntity$inboundSchema.optional(),
  license: z.lazy(() => License$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "private_note": "privateNote",
    "license_key": "licenseKey",
  });
});
/** @internal */
export type ProductFeatureEntity$Outbound = {
  id?: string | undefined;
  description?: string | undefined;
  type?: string | undefined;
  private_note?: string | undefined;
  file?: FileFeatureEntity$Outbound | undefined;
  license_key?: LicenseEntity$Outbound | undefined;
  license?: License$Outbound | undefined;
};

/** @internal */
export const ProductFeatureEntity$outboundSchema: z.ZodType<
  ProductFeatureEntity$Outbound,
  z.ZodTypeDef,
  ProductFeatureEntity
> = z.object({
  id: z.string().optional(),
  description: z.string().optional(),
  type: ProductFeatureType$outboundSchema.optional(),
  privateNote: z.string().optional(),
  file: FileFeatureEntity$outboundSchema.optional(),
  licenseKey: LicenseEntity$outboundSchema.optional(),
  license: z.lazy(() => License$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    privateNote: "private_note",
    licenseKey: "license_key",
  });
});

export function productFeatureEntityToJSON(
  productFeatureEntity: ProductFeatureEntity,
): string {
  return JSON.stringify(
    ProductFeatureEntity$outboundSchema.parse(productFeatureEntity),
  );
}
export function productFeatureEntityFromJSON(
  jsonString: string,
): SafeParseResult<ProductFeatureEntity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ProductFeatureEntity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ProductFeatureEntity' from JSON`,
  );
}
