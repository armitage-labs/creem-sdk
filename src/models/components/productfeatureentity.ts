/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  EnvironmentMode,
  EnvironmentMode$inboundSchema,
  EnvironmentMode$outboundSchema,
} from "./environmentmode.js";
import {
  FeatureFileEntity,
  FeatureFileEntity$inboundSchema,
  FeatureFileEntity$Outbound,
  FeatureFileEntity$outboundSchema,
} from "./featurefileentity.js";
import {
  LicenseStatus,
  LicenseStatus$inboundSchema,
  LicenseStatus$outboundSchema,
} from "./licensestatus.js";
import {
  ProductFeatureType,
  ProductFeatureType$inboundSchema,
  ProductFeatureType$outboundSchema,
} from "./productfeaturetype.js";

/**
 * File feature data containing downloadable files.
 */
export type FileT = {
  /**
   * List of downloadable files.
   */
  files: Array<FeatureFileEntity>;
};

/**
 * The status of the license instance.
 */
export const ProductFeatureEntityStatus = {
  Active: "active",
  Deactivated: "deactivated",
} as const;
/**
 * The status of the license instance.
 */
export type ProductFeatureEntityStatus = ClosedEnum<
  typeof ProductFeatureEntityStatus
>;

/**
 * Associated license instances.
 */
export type ProductFeatureEntityLicenseKeyInstance = {
  /**
   * Unique identifier for the object.
   */
  id: string;
  /**
   * String representing the environment.
   */
  mode: EnvironmentMode;
  /**
   * A string representing the object’s type. Objects of the same type share the same value.
   */
  object: string;
  /**
   * The name of the license instance.
   */
  name: string;
  /**
   * The status of the license instance.
   */
  status: ProductFeatureEntityStatus;
  /**
   * The creation date of the license instance.
   */
  createdAt: Date;
};

/**
 * License key issued for the order.
 */
export type LicenseKey = {
  /**
   * Unique identifier for the object.
   */
  id: string;
  /**
   * String representing the environment.
   */
  mode: EnvironmentMode;
  /**
   * A string representing the object’s type. Objects of the same type share the same value.
   */
  object: string;
  /**
   * The current status of the license key.
   */
  status: LicenseStatus;
  /**
   * The license key.
   */
  key: string;
  /**
   * The number of instances that this license key was activated.
   */
  activation: number;
  /**
   * The activation limit. Null if activations are unlimited.
   */
  activationLimit?: number | null | undefined;
  /**
   * The date the license key expires. Null if it does not have an expiration date.
   */
  expiresAt?: Date | null | undefined;
  /**
   * The creation date of the license key.
   */
  createdAt: Date;
  /**
   * Associated license instances.
   */
  instance?: ProductFeatureEntityLicenseKeyInstance | null | undefined;
};

/**
 * The status of the license instance.
 */
export const ProductFeatureEntityLicenseStatus = {
  Active: "active",
  Deactivated: "deactivated",
} as const;
/**
 * The status of the license instance.
 */
export type ProductFeatureEntityLicenseStatus = ClosedEnum<
  typeof ProductFeatureEntityLicenseStatus
>;

/**
 * Associated license instances.
 */
export type ProductFeatureEntityInstance = {
  /**
   * Unique identifier for the object.
   */
  id: string;
  /**
   * String representing the environment.
   */
  mode: EnvironmentMode;
  /**
   * A string representing the object’s type. Objects of the same type share the same value.
   */
  object: string;
  /**
   * The name of the license instance.
   */
  name: string;
  /**
   * The status of the license instance.
   */
  status: ProductFeatureEntityLicenseStatus;
  /**
   * The creation date of the license instance.
   */
  createdAt: Date;
};

/**
 * DEPRECATED: Use `license_key` instead. License key issued for the order.
 *
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type License = {
  /**
   * Unique identifier for the object.
   */
  id: string;
  /**
   * String representing the environment.
   */
  mode: EnvironmentMode;
  /**
   * A string representing the object’s type. Objects of the same type share the same value.
   */
  object: string;
  /**
   * The current status of the license key.
   */
  status: LicenseStatus;
  /**
   * The license key.
   */
  key: string;
  /**
   * The number of instances that this license key was activated.
   */
  activation: number;
  /**
   * The activation limit. Null if activations are unlimited.
   */
  activationLimit?: number | null | undefined;
  /**
   * The date the license key expires. Null if it does not have an expiration date.
   */
  expiresAt?: Date | null | undefined;
  /**
   * The creation date of the license key.
   */
  createdAt: Date;
  /**
   * Associated license instances.
   */
  instance?: ProductFeatureEntityInstance | null | undefined;
};

export type ProductFeatureEntity = {
  /**
   * Unique identifier for the feature.
   */
  id?: string | null | undefined;
  /**
   * A brief description of the feature.
   */
  description?: string | null | undefined;
  /**
   * The type of the feature: privateNote (custom note), file (downloadable files), or licenseKey (license key).
   */
  type?: ProductFeatureType | undefined;
  /**
   * Private note from the seller. This is only visible to the customer after purchase.
   */
  privateNote?: string | null | undefined;
  /**
   * File feature data containing downloadable files.
   */
  file?: FileT | null | undefined;
  /**
   * License key issued for the order.
   */
  licenseKey?: LicenseKey | null | undefined;
  /**
   * DEPRECATED: Use `license_key` instead. License key issued for the order.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  license?: License | null | undefined;
};

/** @internal */
export const FileT$inboundSchema: z.ZodType<FileT, z.ZodTypeDef, unknown> = z
  .object({
    files: z.array(FeatureFileEntity$inboundSchema),
  });
/** @internal */
export type FileT$Outbound = {
  files: Array<FeatureFileEntity$Outbound>;
};

/** @internal */
export const FileT$outboundSchema: z.ZodType<
  FileT$Outbound,
  z.ZodTypeDef,
  FileT
> = z.object({
  files: z.array(FeatureFileEntity$outboundSchema),
});

export function fileToJSON(fileT: FileT): string {
  return JSON.stringify(FileT$outboundSchema.parse(fileT));
}
export function fileFromJSON(
  jsonString: string,
): SafeParseResult<FileT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FileT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FileT' from JSON`,
  );
}

/** @internal */
export const ProductFeatureEntityStatus$inboundSchema: z.ZodNativeEnum<
  typeof ProductFeatureEntityStatus
> = z.nativeEnum(ProductFeatureEntityStatus);
/** @internal */
export const ProductFeatureEntityStatus$outboundSchema: z.ZodNativeEnum<
  typeof ProductFeatureEntityStatus
> = ProductFeatureEntityStatus$inboundSchema;

/** @internal */
export const ProductFeatureEntityLicenseKeyInstance$inboundSchema: z.ZodType<
  ProductFeatureEntityLicenseKeyInstance,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  mode: EnvironmentMode$inboundSchema,
  object: z.string(),
  name: z.string(),
  status: ProductFeatureEntityStatus$inboundSchema,
  created_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
}).transform((v) => {
  return remap$(v, {
    "created_at": "createdAt",
  });
});
/** @internal */
export type ProductFeatureEntityLicenseKeyInstance$Outbound = {
  id: string;
  mode: string;
  object: string;
  name: string;
  status: string;
  created_at: string;
};

/** @internal */
export const ProductFeatureEntityLicenseKeyInstance$outboundSchema: z.ZodType<
  ProductFeatureEntityLicenseKeyInstance$Outbound,
  z.ZodTypeDef,
  ProductFeatureEntityLicenseKeyInstance
> = z.object({
  id: z.string(),
  mode: EnvironmentMode$outboundSchema,
  object: z.string(),
  name: z.string(),
  status: ProductFeatureEntityStatus$outboundSchema,
  createdAt: z.date().transform(v => v.toISOString()),
}).transform((v) => {
  return remap$(v, {
    createdAt: "created_at",
  });
});

export function productFeatureEntityLicenseKeyInstanceToJSON(
  productFeatureEntityLicenseKeyInstance:
    ProductFeatureEntityLicenseKeyInstance,
): string {
  return JSON.stringify(
    ProductFeatureEntityLicenseKeyInstance$outboundSchema.parse(
      productFeatureEntityLicenseKeyInstance,
    ),
  );
}
export function productFeatureEntityLicenseKeyInstanceFromJSON(
  jsonString: string,
): SafeParseResult<ProductFeatureEntityLicenseKeyInstance, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ProductFeatureEntityLicenseKeyInstance$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ProductFeatureEntityLicenseKeyInstance' from JSON`,
  );
}

/** @internal */
export const LicenseKey$inboundSchema: z.ZodType<
  LicenseKey,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  mode: EnvironmentMode$inboundSchema,
  object: z.string(),
  status: LicenseStatus$inboundSchema,
  key: z.string(),
  activation: z.number(),
  activation_limit: z.nullable(z.number()).optional(),
  expires_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  created_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  instance: z.nullable(
    z.lazy(() => ProductFeatureEntityLicenseKeyInstance$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "activation_limit": "activationLimit",
    "expires_at": "expiresAt",
    "created_at": "createdAt",
  });
});
/** @internal */
export type LicenseKey$Outbound = {
  id: string;
  mode: string;
  object: string;
  status: string;
  key: string;
  activation: number;
  activation_limit?: number | null | undefined;
  expires_at?: string | null | undefined;
  created_at: string;
  instance?: ProductFeatureEntityLicenseKeyInstance$Outbound | null | undefined;
};

/** @internal */
export const LicenseKey$outboundSchema: z.ZodType<
  LicenseKey$Outbound,
  z.ZodTypeDef,
  LicenseKey
> = z.object({
  id: z.string(),
  mode: EnvironmentMode$outboundSchema,
  object: z.string(),
  status: LicenseStatus$outboundSchema,
  key: z.string(),
  activation: z.number(),
  activationLimit: z.nullable(z.number()).optional(),
  expiresAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  createdAt: z.date().transform(v => v.toISOString()),
  instance: z.nullable(
    z.lazy(() => ProductFeatureEntityLicenseKeyInstance$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    activationLimit: "activation_limit",
    expiresAt: "expires_at",
    createdAt: "created_at",
  });
});

export function licenseKeyToJSON(licenseKey: LicenseKey): string {
  return JSON.stringify(LicenseKey$outboundSchema.parse(licenseKey));
}
export function licenseKeyFromJSON(
  jsonString: string,
): SafeParseResult<LicenseKey, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LicenseKey$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LicenseKey' from JSON`,
  );
}

/** @internal */
export const ProductFeatureEntityLicenseStatus$inboundSchema: z.ZodNativeEnum<
  typeof ProductFeatureEntityLicenseStatus
> = z.nativeEnum(ProductFeatureEntityLicenseStatus);
/** @internal */
export const ProductFeatureEntityLicenseStatus$outboundSchema: z.ZodNativeEnum<
  typeof ProductFeatureEntityLicenseStatus
> = ProductFeatureEntityLicenseStatus$inboundSchema;

/** @internal */
export const ProductFeatureEntityInstance$inboundSchema: z.ZodType<
  ProductFeatureEntityInstance,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  mode: EnvironmentMode$inboundSchema,
  object: z.string(),
  name: z.string(),
  status: ProductFeatureEntityLicenseStatus$inboundSchema,
  created_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
}).transform((v) => {
  return remap$(v, {
    "created_at": "createdAt",
  });
});
/** @internal */
export type ProductFeatureEntityInstance$Outbound = {
  id: string;
  mode: string;
  object: string;
  name: string;
  status: string;
  created_at: string;
};

/** @internal */
export const ProductFeatureEntityInstance$outboundSchema: z.ZodType<
  ProductFeatureEntityInstance$Outbound,
  z.ZodTypeDef,
  ProductFeatureEntityInstance
> = z.object({
  id: z.string(),
  mode: EnvironmentMode$outboundSchema,
  object: z.string(),
  name: z.string(),
  status: ProductFeatureEntityLicenseStatus$outboundSchema,
  createdAt: z.date().transform(v => v.toISOString()),
}).transform((v) => {
  return remap$(v, {
    createdAt: "created_at",
  });
});

export function productFeatureEntityInstanceToJSON(
  productFeatureEntityInstance: ProductFeatureEntityInstance,
): string {
  return JSON.stringify(
    ProductFeatureEntityInstance$outboundSchema.parse(
      productFeatureEntityInstance,
    ),
  );
}
export function productFeatureEntityInstanceFromJSON(
  jsonString: string,
): SafeParseResult<ProductFeatureEntityInstance, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ProductFeatureEntityInstance$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ProductFeatureEntityInstance' from JSON`,
  );
}

/** @internal */
export const License$inboundSchema: z.ZodType<License, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string(),
    mode: EnvironmentMode$inboundSchema,
    object: z.string(),
    status: LicenseStatus$inboundSchema,
    key: z.string(),
    activation: z.number(),
    activation_limit: z.nullable(z.number()).optional(),
    expires_at: z.nullable(
      z.string().datetime({ offset: true }).transform(v => new Date(v)),
    ).optional(),
    created_at: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ),
    instance: z.nullable(
      z.lazy(() => ProductFeatureEntityInstance$inboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "activation_limit": "activationLimit",
      "expires_at": "expiresAt",
      "created_at": "createdAt",
    });
  });
/** @internal */
export type License$Outbound = {
  id: string;
  mode: string;
  object: string;
  status: string;
  key: string;
  activation: number;
  activation_limit?: number | null | undefined;
  expires_at?: string | null | undefined;
  created_at: string;
  instance?: ProductFeatureEntityInstance$Outbound | null | undefined;
};

/** @internal */
export const License$outboundSchema: z.ZodType<
  License$Outbound,
  z.ZodTypeDef,
  License
> = z.object({
  id: z.string(),
  mode: EnvironmentMode$outboundSchema,
  object: z.string(),
  status: LicenseStatus$outboundSchema,
  key: z.string(),
  activation: z.number(),
  activationLimit: z.nullable(z.number()).optional(),
  expiresAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  createdAt: z.date().transform(v => v.toISOString()),
  instance: z.nullable(
    z.lazy(() => ProductFeatureEntityInstance$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    activationLimit: "activation_limit",
    expiresAt: "expires_at",
    createdAt: "created_at",
  });
});

export function licenseToJSON(license: License): string {
  return JSON.stringify(License$outboundSchema.parse(license));
}
export function licenseFromJSON(
  jsonString: string,
): SafeParseResult<License, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => License$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'License' from JSON`,
  );
}

/** @internal */
export const ProductFeatureEntity$inboundSchema: z.ZodType<
  ProductFeatureEntity,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  type: ProductFeatureType$inboundSchema.optional(),
  private_note: z.nullable(z.string()).optional(),
  file: z.nullable(z.lazy(() => FileT$inboundSchema)).optional(),
  license_key: z.nullable(z.lazy(() => LicenseKey$inboundSchema)).optional(),
  license: z.nullable(z.lazy(() => License$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "private_note": "privateNote",
    "license_key": "licenseKey",
  });
});
/** @internal */
export type ProductFeatureEntity$Outbound = {
  id?: string | null | undefined;
  description?: string | null | undefined;
  type?: string | undefined;
  private_note?: string | null | undefined;
  file?: FileT$Outbound | null | undefined;
  license_key?: LicenseKey$Outbound | null | undefined;
  license?: License$Outbound | null | undefined;
};

/** @internal */
export const ProductFeatureEntity$outboundSchema: z.ZodType<
  ProductFeatureEntity$Outbound,
  z.ZodTypeDef,
  ProductFeatureEntity
> = z.object({
  id: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  type: ProductFeatureType$outboundSchema.optional(),
  privateNote: z.nullable(z.string()).optional(),
  file: z.nullable(z.lazy(() => FileT$outboundSchema)).optional(),
  licenseKey: z.nullable(z.lazy(() => LicenseKey$outboundSchema)).optional(),
  license: z.nullable(z.lazy(() => License$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    privateNote: "private_note",
    licenseKey: "license_key",
  });
});

export function productFeatureEntityToJSON(
  productFeatureEntity: ProductFeatureEntity,
): string {
  return JSON.stringify(
    ProductFeatureEntity$outboundSchema.parse(productFeatureEntity),
  );
}
export function productFeatureEntityFromJSON(
  jsonString: string,
): SafeParseResult<ProductFeatureEntity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ProductFeatureEntity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ProductFeatureEntity' from JSON`,
  );
}
